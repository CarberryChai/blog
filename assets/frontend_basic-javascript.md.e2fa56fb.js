import{o as e,c as a,a as t}from"./app.0bf1fc6c.js";const l='{"title":"Javascript 基础","description":"","frontmatter":{},"headers":[{"level":2,"title":"1、scope","slug":"_1、scope"},{"level":2,"title":"2、Call Stack、Event Loop、 Callback Queue","slug":"_2、call-stack、event-loop、-callback-queue"},{"level":2,"title":"3、什么是requestIdleCallback ? 干什么用的？","slug":"_3、什么是requestidlecallback-干什么用的？"},{"level":2,"title":"4、JS原型、原型链的理解？","slug":"_4、js原型、原型链的理解？"},{"level":2,"title":"5、如何实现原型继承？","slug":"_5、如何实现原型继承？"}],"relativePath":"frontend/basic-javascript.md","lastUpdated":1621234023500}',r={},c=t('<h1 id="javascript-基础"><a class="header-anchor" href="#javascript-基础" aria-hidden="true">#</a> Javascript 基础</h1><h2 id="_1、scope"><a class="header-anchor" href="#_1、scope" aria-hidden="true">#</a> 1、scope</h2><p>Scope in Javascript refers to the accessibility or visibility of variables. That is, which parts of a paragram have access to the variable or where the variable is visible.</p><p>作用域又分为两种，静态作用域和动态作用域。</p><p>大多数现代编程语言都采用静态作用域规则，如C/C++、C#、Python、Java、JavaScript....</p><p>静态作用域又叫词法作用域（Lexical Scope）， literally means that scope is determined at the <a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" rel="noopener noreferrer">lexing time</a> (generally referred to as compiling) rather than at runtime.</p><p>JavaScript 作用域主要分为三类：</p><ul><li>Global Scope</li><li>Function Scope</li><li>Block Scope</li></ul><h2 id="_2、call-stack、event-loop、-callback-queue"><a class="header-anchor" href="#_2、call-stack、event-loop、-callback-queue" aria-hidden="true">#</a> 2、Call Stack、Event Loop、 Callback Queue</h2><p><img src="https://cdn.jsdelivr.net/gh/CarberryChai/oss@master/image/vdpaCc-qaUgCP.jpg" alt=""></p><p><strong>The call stack</strong></p><p><strong>Javascript is a single-threaded programming language, which means it has a single Call Stack. Therefore it can do one thing at a time.</strong></p><p><strong>The Call Stack is a data structue which records basically where in the program we are.</strong></p><h2 id="_3、什么是requestidlecallback-干什么用的？"><a class="header-anchor" href="#_3、什么是requestidlecallback-干什么用的？" aria-hidden="true">#</a> 3、什么是requestIdleCallback ? 干什么用的？</h2><blockquote><p>The <code>window.requestIdleCallback()</code> method queues a function to be called during a browser&#39;s idle periods. This enables developers to perform background and low priority work on the main event loop, without impacting latency-critical events such as animation and input response.</p></blockquote><p><code>requestIdleCallback</code>使浏览器在空闲时期调用的函数加入一个队列。它能够让开发者在主线程执行一些低优先级的任务，不会影响一些对延迟敏感的事件，比如动画、响应用户输入等。</p><h2 id="_4、js原型、原型链的理解？"><a class="header-anchor" href="#_4、js原型、原型链的理解？" aria-hidden="true">#</a> 4、JS原型、原型链的理解？</h2><p>JS原型是指为其他对象提供共享属性访问的对象。在创建对象时，每个对象都包含一个隐式引用指向它的原型对象或者null。</p><p>原型也是对象，因此它也有自己的原型。这样就构成一个原型链。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/87667349" target="_blank" rel="noopener noreferrer">进阶必读：深入理解 JavaScript 原型</a></p></blockquote><h2 id="_5、如何实现原型继承？"><a class="header-anchor" href="#_5、如何实现原型继承？" aria-hidden="true">#</a> 5、如何实现原型继承？</h2><ul><li>一种是通过<code>Object.create</code>或者<code>Object.setPrototypeOf</code>显式继承另一个对象，将它设置为原型。</li><li>另一种是通过构造函数，在使用<code>new</code>关键字实例化时，会自动继承构造函数（<code>constructor</code>）的<code>prototype</code>对象，作为实例的原型。</li><li>在ES2015中提供了class的风格，背后跟函数（<code>constructor</code>）工作方式一样，写起来更内聚一点。</li></ul>',22);r.render=function(t,l,r,i,o,s){return e(),a("div",null,[c])};export default r;export{l as __pageData};
